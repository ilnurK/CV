#!/usr/bin/env python3
"""Module contains a client for grpc server which receives battleships

The client receives a set of coordinates in the equatorial system in
the CLI, receives back a stream of battleships checked by constraints,
displays them in the CLI and adds them to the data_ships and
data_officers databases (creates them if they do not exist).
The client can also scan the transmitted coordinates to search for
traitors - the same officers (with a unique combination of first name,
last name and rank) can be found on both allied and enemy ships,
after which the list_traitors command adds them to the table

The script requires argument_parsing module to check inputted
coordinates and arguments, grpc library on which the client is based,
battleship_pydantic - to validate message, json module to output
the messages in json format, sqlalchemy and tables_crud to work with
Postgresql database and sys to import modules generated by protobuf
files from another directory
"""

# fmt: off
import grpc
import json
import os
from pydantic import ValidationError
from sqlalchemy.engine.url import URL
from sqlalchemy import create_engine
from sqlalchemy.orm import Session
from typing import Dict, List, Any, Iterator

import arguments_parsing as ap
import battleship_pydantic as bp
import data_tables as dt
import tables_crud as tc
import sys
sys.path.append("../protobuf")
sys.path.append("../common_files")
import battleship_pb2_grpc as pb2g  # type: ignore # noqa E402
import battleship_pb2 as pb2   # type: ignore # noqa E402
from common import prompt_env_var  # type: ignore # noqa E402
# fmt: on


def run(session: Session) -> None:
    '''Client for grpc server, sends coordinates, receives battleships

    Defines the client of gRPC server, expects a galactic coordinates
    as input, and recieves a stream of ships located at this coordinates
    as output

    Parameters
    ----------
    session: Session
        The sqlalchemy session
    '''

    with grpc.insecure_channel('localhost:8888') as channel:
        stub: pb2g.ExploreSpaceStub = pb2g.ExploreSpaceStub(channel)
        request: pb2.coordinates_request = pb2.coordinates_request()
        args: ap.Args = ap.args_parse()
        if args.list_clear:
            tc.traitors_clear(session)
        elif args.tables_clear:
            tc.tables_clear(session)
        elif args.list_traitors:
            tc.traitors_handle(session)
        else:
            request.coordinates = args.ra_hour + args.ra_min + args.ra_sec *\
                1e4 + args.dec_deg + args.dec_min + args.dec_sec * 1e4
            battleships_response: Iterator[pb2.battleship] =\
                stub.get_battleships(request)
            align_enum: List[str] = pb2.battleship.alignments.keys()
            ship_enum: List[str] = pb2.battleship.ship_classes.keys()
            constraints: Dict[str, Dict[str, str]] = get_constraints()
            for bship in battleships_response:
                ship: Dict[str, Any] =\
                    get_ship_dict(bship, align_enum, ship_enum, constraints)
                try:
                    bp.Battleship(**ship)
                    ship.pop('constraints')
                    ship_print(ship)
                    tc.ship_register(ship, session, args.scan)
                except ValidationError:
                    pass


def get_constraints() -> Dict[str, Dict[str, str]]:
    """Obtaining the constraint dictionary needed to validate message

    Raises
    ------
    IOError
       If environment variable is not set or constraints file is empty
    """

    data_dir: str | None = os.getenv("DATA_DIR")
    constraints: Dict[str, Dict[str, str]] = {}
    if data_dir is None:
        raise IOError("DATA_DIR environment variable doesn't set")
    constraints_path = data_dir + "/constraints.json"
    with open(constraints_path, 'r') as inp:
        constraints = json.load(inp)
    if not len(constraints):
        raise IOError(constraints_path)
    return constraints


def get_ship_dict(battleship: pb2.battleship, align_enum: List[str],
                  ship_enum: List[str], constraints: Dict[str, Any])\
        -> Dict[str, Any]:
    """Prepare dictionary for json from protobuf message

    Parameters
    ----------
    battleship: pb2.battleship
        The battleship class message
    align_enum
        The list of battleship alignment types
    ship_enum
        The list of battleship class types
    constraints
        The dictionary of battleship constraints for validate message

    Returns
    -------
    Dict[str, Any]
        Battleship characteristics
    """

    ship: Dict[str, Any] = {}
    ship['alignment'] = align_enum[battleship.alignment]
    ship['name'] = battleship.name
    ship['class'] = ship_enum[battleship.ship_class]
    ship['length'] = round(battleship.length, 1)
    ship['crew_size'] = battleship.crew_size
    ship['armed'] = True if battleship.armed else False
    ship['officers'] = [
        {i: getattr(officer, i) for i in
            ('first_name', 'last_name', 'rank')}
        for officer in battleship.officers]
    ship['constraints'] = constraints
    return ship


def ship_print(ship: Dict[str, Any]):
    """Output battleship message in json format

    Parameters
    ----------
    ship: Dict[str, Any]
        The dictionary obtained from battleship message
    """

    part_without_officers = json.dumps(ship, ensure_ascii=False, indent=2)
    part_with_officers = json.dumps(ship, ensure_ascii=False)

    split_part = '  "officers"'
    before_officers = part_without_officers.split(split_part)[0]
    after_officers = part_with_officers.split(split_part[1:])[1]

    print(before_officers, end='')
    print(split_part, end='')
    print(after_officers.replace(']}', ']\n}'))


def main() -> None:
    """Main program cycle"""
    try:
        sql_args: Dict[str, str] = {
            'base': 'enders_game',
            'host': 'localhost',
            'user': 'ender',
            'pass': 'Wiggin',
            'std': 'postgres'
        }
        tc.create_db_and_user(sql_args)
        url_object = URL.create(
            "postgresql+psycopg2",
            username=sql_args['user'],
            password=sql_args['pass'],
            host=sql_args['host'],
            database=sql_args['base']
        )
        engine = create_engine(url_object)
        dt.Base.metadata.create_all(engine)
        session = Session(engine)
        run(session)
    except ValueError as e:
        print(f'Error occured:\n{e}')
    except IOError as e:
        print(f'Error occured:\n{e}')
        env_var: str = 'DATA_DIR'
        is_restart: bool = prompt_env_var(env_var)
        main() if is_restart else None
    except OSError as e:
        print(f'Error occured:\n{e}')
    except Exception as e:
        print(f'Error occured:\n{e}')


if __name__ == '__main__':
    main()
