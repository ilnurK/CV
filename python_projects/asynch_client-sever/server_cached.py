#!/usr/bin/env python3
"""FastApi server that creates task to receive status codes from URLs

Client submits all URLs request to a server endpoint /api/v1/tasks/.
Server responds with HTTP 201 and a task object, then starts
asynchronously sending GET requests to submitted URLs and collecting
HTTP response codes

The script requires fastapi to create server itself, aiohttp, asyncio -
for asynchronous request processing, uuid - to generate unique task id,
pydantic - to check the request body.
"""

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from aiohttp import ClientSession
from aiohttp.client_exceptions import ClientOSError, ClientConnectorError
import asyncio
from uuid import uuid4
from pydantic import BaseModel, field_validator
import redis
from typing import List
import enum


class RequestValidate(BaseModel):
    """The class for validating incoming request

    Attributes
    ----------
    urls: List[str]
        The list of given urls
    """

    urls: List[str]

    @field_validator('urls')
    def check_url(cls, urls: List[str]) -> List[str]:
        """Validate incoming list of URLs

        Parameters
        ----------
        urls : List[str]
            The specified list of URLs that need to be validated

        Raises
        ------
        ValueError
            If the URL protocol is incorrect
        ValueError
            If the URL domain is incorrect

        Returns
        -------
        List[str]
            Incoming list of URLs
        """

        for url in urls:
            if not (url.startswith("http://") or url.startswith("https://")):
                raise ValueError('URL must start with http(s)://', url)
            domain: List[str] = url[url.find(':') + 3:].split('.')
            if len(domain) == 1 or not all(len(part) >= 2 for part in domain):
                raise ValueError('domain incorrect', url)
        return urls


class Task(BaseModel):
    """Task object for response to client

    Attributes
    ----------
    ID: str
        Task id generated by uuid4
    status: str
        Task status ("running" or "ready")
    result: List[str]
        The list of response - url pair
    connects: int
        The 2xx response codes counter
    errors: int
        Other response codes counter
    """

    ID: str
    status: str
    result: List[str]
    connects: int
    cached: int
    errors: int


class Cached(enum.Enum):
    ERROR = -1
    NOT_CACHED = 0
    CACHED = 1


APP = FastAPI()
TASK: Task = Task(ID="", status="", result=[], connects=0, cached=0, errors=0)
REDIS1 = redis.Redis(host="localhost", port=6379, db=0)
REDIS2 = redis.Redis(host="localhost", port=6379, db=1)
CACHE_TIMEOUT: int = 60


@APP.post("/api/v1/tasks")
async def task_request(urls: RequestValidate) -> JSONResponse:
    """Gets validated list of URLs, returns Task object, and runs task

    Client submits all URLs via HTTP POST request as a JSON list to a
    server endpoint /api/v1/tasks/.

    Server responds with HTTP 201 and a task object, then starts
    asynchronously sending HTTP GET requests to submitted URLs and
    collecting HTTP response codes

    Parameters
    ----------
    urls: RequestValidate
        Client provided validated URLs

    Returns
    -------
    JSONResponse
        Contains status code and the task object status - 'running'
    """

    task_urls: List[str] = urls.dict()["urls"]
    global TASK
    TASK = Task(
        ID=str(uuid4()),
        status="running",
        result=[],
        connects=0,
        cached=0,
        errors=0,
    )

    asyncio.create_task(get_codes(TASK, task_urls))
    return JSONResponse(status_code=201, content=TASK.dict())


async def get_codes(TASK: Task, task_urls: List[str]) -> None:
    """Starts a session and gathers tasks

    Parameters
    ----------
    TASK: Task
        Object to send to the client
    task_urls: List[str]
        URLs that needed to be parsed
    """

    async with ClientSession() as session:
        await asyncio.gather(
            *[get_code(session, str(url)) for url in task_urls]
        )
        asyncio.create_task(clean_cache())
    TASK.status = "ready"


async def get_code(session: ClientSession, url: str) -> None:
    """Get the status code of the specified URL

    Parameters
    ----------
    session: ClientSession
        The aiohttp connection session
    url: str
        URL to get the response status code from
    """

    async def exception_handle(text: str = "", status_code: int = 500) -> None:
        """Prints an exception message and adds some delay

        Parameters
        ----------
        text: str
            The error description (defaults '')
        status_code: int
            The response status code (defaults 500)
        """

        print(f"Error connecting to {url}. {text}")
        delay = 0.1
        await asyncio.sleep(delay)
        TASK.result.append(f"{status_code}\t{url}")
        TASK.errors += 1

    try:
        cached_res: Cached = is_cached_request(url)
        if cached_res != Cached.CACHED:
            await request_code_without_cache(session, url, cached_res)
        counter_domains(url)
    except ClientConnectorError:
        await exception_handle()
    except asyncio.exceptions.TimeoutError:
        await exception_handle("Timeout", 408)
    except ClientOSError:
        await exception_handle("Client Error")
    except Exception as e:
        await exception_handle(f"Unpredictable Error: {e}")


def is_cached_request(url: str) -> Cached:
    """Checks if the request has been cached and adds it to task if so

    Parameters
    ----------
    url: str
        The URL needs to be checked

    Returns
    -------
    Cached
        The cached status
    """

    cached_res: Cached = Cached.NOT_CACHED
    try:
        status: bytes = REDIS1.get(url)  # type: ignore
        if status:
            TASK.result.append(f"{str(status, 'utf-8')}\t{url}")
            TASK.cached += 1
            cached_res = Cached.CACHED
    except redis.exceptions.ConnectionError:
        cached_res = Cached.ERROR
        print("redis server is not running")
    return cached_res


async def request_code_without_cache(
    session: ClientSession, url: str, cached_res: Cached
) -> None:
    """Request status code from given url and add to cache

    Parameters
    ----------
    session: ClientSession
        The aiohttp client session
    url: str
        The URL to get the response from
    cached_res: Cached
        The cached status
    """

    status = await request_code(session, url)
    TASK.result.append(f"{status}\t{url}")
    if cached_res != Cached.ERROR:
        REDIS1.set(url, status)
    if status >= 200 and status < 300:
        TASK.connects += 1
    else:
        TASK.errors += 1


async def request_code(session: ClientSession, url: str) -> int:
    """Request status code from given url

    Parameters
    ----------
    session: ClientSession
        The aiohttp client session
    url: str
        The URL to get the response from

    Returns
    -------
    int
        The response status code
    """

    print(f"connected to {url}")
    timeout: int = 3
    async with session.get(url, timeout=timeout) as response:
        status: int = response.status
    return status


def counter_domains(url: str) -> None:
    """Increase the counter of domain

    Parameters
    ----------
    url : str
       The URL from which the domain is extracted
    """

    url = url[url.find(":") + 3:]
    first_slash = url.find("/")
    if first_slash < 0:
        first_slash = len(url)
    domain: str = url[:first_slash]
    REDIS2.incr(domain)


@APP.get("/api/v1/tasks/domain_counter/")
async def request_domain_counter() -> List[str]:
    """Gives a list of counted domains

    Returns
    -------
    List[str]
        The list of pairs - url, quantity
    """

    domains: List[bytes] = REDIS2.keys()  # type: ignore
    lst: List[str] = []
    for domain in domains:
        lst.append(f"{str(domain, 'utf-8')}\t{REDIS2.get(domain)}\n")
    return lst


@APP.get("/api/v1/tasks/{uuid}")
def request_by_uuid() -> Task:
    """Returns TASK by the TASK request endpoint

    Returns
    -------
    Task
        The client requested Task object
    """

    return TASK


async def clean_cache():
    """Cleans redis databases"""
    await asyncio.sleep(CACHE_TIMEOUT)
    REDIS1.flushdb()
    REDIS2.flushdb()


if __name__ == "__main__":
    import uvicorn

    port: int = 8888
    try:
        uvicorn.run(APP, port=port)
    except AttributeError as e:
        print(e)
    except Exception as e:
        print(e)
